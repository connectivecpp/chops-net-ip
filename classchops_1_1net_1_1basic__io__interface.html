<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Chops Net IP: chops::net::basic_io_interface&lt; IOT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Chops Net IP
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>chops</b></li><li class="navelem"><b>net</b></li><li class="navelem"><a class="el" href="classchops_1_1net_1_1basic__io__interface.html">basic_io_interface</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classchops_1_1net_1_1basic__io__interface-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">chops::net::basic_io_interface&lt; IOT &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> class template provides access to an underlying network IO handler (TCP or UDP IO handler), primarily for calling the <code>start_io</code>, <code>stop_io</code>, and <code>make_io_output</code> methods.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="basic__io__interface_8hpp_source.html">basic_io_interface.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a317e45fefcbc2a9a7047a2d28de6f93e" id="r_a317e45fefcbc2a9a7047a2d28de6f93e"><td class="memItemLeft" align="right" valign="top"><a id="a317e45fefcbc2a9a7047a2d28de6f93e" name="a317e45fefcbc2a9a7047a2d28de6f93e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>endpoint_type</b> = typename IOT::endpoint_type</td></tr>
<tr class="separator:a317e45fefcbc2a9a7047a2d28de6f93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7a8a1629cbe35c659fd5455ba3132649" id="r_a7a8a1629cbe35c659fd5455ba3132649"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a8a1629cbe35c659fd5455ba3132649">basic_io_interface</a> ()=default</td></tr>
<tr class="memdesc:a7a8a1629cbe35c659fd5455ba3132649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default construct a <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code>.  <br /></td></tr>
<tr class="separator:a7a8a1629cbe35c659fd5455ba3132649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3602a38fecf897dac82c3931ecd3e4" id="r_a9b3602a38fecf897dac82c3931ecd3e4"><td class="memItemLeft" align="right" valign="top"><a id="a9b3602a38fecf897dac82c3931ecd3e4" name="a9b3602a38fecf897dac82c3931ecd3e4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>basic_io_interface</b> (const <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">basic_io_interface</a> &amp;)=default</td></tr>
<tr class="separator:a9b3602a38fecf897dac82c3931ecd3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4604b6f47baaa72aec3aec57d42ad3" id="r_a2a4604b6f47baaa72aec3aec57d42ad3"><td class="memItemLeft" align="right" valign="top"><a id="a2a4604b6f47baaa72aec3aec57d42ad3" name="a2a4604b6f47baaa72aec3aec57d42ad3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>basic_io_interface</b> (<a class="el" href="classchops_1_1net_1_1basic__io__interface.html">basic_io_interface</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a2a4604b6f47baaa72aec3aec57d42ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c396b84a87529da57a8bc9c99eb09c7" id="r_a0c396b84a87529da57a8bc9c99eb09c7"><td class="memItemLeft" align="right" valign="top"><a id="a0c396b84a87529da57a8bc9c99eb09c7" name="a0c396b84a87529da57a8bc9c99eb09c7"></a>
<a class="el" href="classchops_1_1net_1_1basic__io__interface.html">basic_io_interface</a>&lt; IOT &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">basic_io_interface</a> &amp;)=default</td></tr>
<tr class="separator:a0c396b84a87529da57a8bc9c99eb09c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ebc593c5197ca8bb2dcea034fe9f30" id="r_a90ebc593c5197ca8bb2dcea034fe9f30"><td class="memItemLeft" align="right" valign="top"><a id="a90ebc593c5197ca8bb2dcea034fe9f30" name="a90ebc593c5197ca8bb2dcea034fe9f30"></a>
<a class="el" href="classchops_1_1net_1_1basic__io__interface.html">basic_io_interface</a>&lt; IOT &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classchops_1_1net_1_1basic__io__interface.html">basic_io_interface</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a90ebc593c5197ca8bb2dcea034fe9f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a1f58c87574a1c813c557c2abf1525" id="r_ab4a1f58c87574a1c813c557c2abf1525"><td class="memItemLeft" align="right" valign="top"><a id="ab4a1f58c87574a1c813c557c2abf1525" name="ab4a1f58c87574a1c813c557c2abf1525"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>basic_io_interface</b> (std::weak_ptr&lt; IOT &gt; p) noexcept</td></tr>
<tr class="memdesc:ab4a1f58c87574a1c813c557c2abf1525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with a shared weak pointer to an internal IO handler, this is an internal constructor only and not to be used by application code. <br /></td></tr>
<tr class="separator:ab4a1f58c87574a1c813c557c2abf1525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf5455c5e73634c98f324069c553c7d" id="r_aadf5455c5e73634c98f324069c553c7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadf5455c5e73634c98f324069c553c7d">is_valid</a> () const noexcept</td></tr>
<tr class="memdesc:aadf5455c5e73634c98f324069c553c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether an IO handler is associated with this object.  <br /></td></tr>
<tr class="separator:aadf5455c5e73634c98f324069c553c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62257614a16c0076afe0244ec6e3ade" id="r_af62257614a16c0076afe0244ec6e3ade"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af62257614a16c0076afe0244ec6e3ade">make_io_output</a> () const -&gt; nonstd::expected&lt; <a class="el" href="classchops_1_1net_1_1basic__io__output.html">basic_io_output</a>&lt; IOT &gt;, std::error_code &gt;</td></tr>
<tr class="memdesc:af62257614a16c0076afe0244ec6e3ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <code><a class="el" href="classchops_1_1net_1_1basic__io__output.html" title="The basic_io_output class template provides methods for sending data to an associated network IO hand...">basic_io_output</a></code> object from the associated IO handler.  <br /></td></tr>
<tr class="separator:af62257614a16c0076afe0244ec6e3ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a69a98211370437e7e745d7e0ed921" id="r_ad9a69a98211370437e7e745d7e0ed921"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9a69a98211370437e7e745d7e0ed921">is_io_started</a> () const -&gt; nonstd::expected&lt; bool, std::error_code &gt;</td></tr>
<tr class="memdesc:ad9a69a98211370437e7e745d7e0ed921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether an IO handler is in a started state or not.  <br /></td></tr>
<tr class="separator:ad9a69a98211370437e7e745d7e0ed921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af5d06c46ef636b1ad12ed98b1daae0" id="r_a1af5d06c46ef636b1ad12ed98b1daae0"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a1af5d06c46ef636b1ad12ed98b1daae0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1af5d06c46ef636b1ad12ed98b1daae0">visit_socket</a> (F &amp;&amp;func) -&gt; nonstd::expected&lt; void, std::error_code &gt;</td></tr>
<tr class="memdesc:a1af5d06c46ef636b1ad12ed98b1daae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an application supplied function object which will be called with a reference to the associated IO handler socket.  <br /></td></tr>
<tr class="separator:a1af5d06c46ef636b1ad12ed98b1daae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e69fa899322103030acca219d65cf2" id="r_a26e69fa899322103030acca219d65cf2"><td class="memTemplParams" colspan="2">template&lt;typename MH , typename MF &gt; </td></tr>
<tr class="memitem:a26e69fa899322103030acca219d65cf2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a26e69fa899322103030acca219d65cf2">start_io</a> (std::size_t header_size, MH &amp;&amp;msg_handler, MF &amp;&amp;msg_frame) -&gt; nonstd::expected&lt; void, std::error_code &gt;</td></tr>
<tr class="memdesc:a26e69fa899322103030acca219d65cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable IO processing for the associated network IO handler with message frame logic.  <br /></td></tr>
<tr class="separator:a26e69fa899322103030acca219d65cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2510763fd04e3b4b36c9026b29d9c2" id="r_a6e2510763fd04e3b4b36c9026b29d9c2"><td class="memTemplParams" colspan="2">template&lt;typename MH &gt; </td></tr>
<tr class="memitem:a6e2510763fd04e3b4b36c9026b29d9c2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6e2510763fd04e3b4b36c9026b29d9c2">start_io</a> (std::size_t header_size, MH &amp;&amp;msg_handler, <a class="el" href="#a070c8dd169c04a878348f2389ea60a35">hdr_decoder_func</a> func) -&gt; nonstd::expected&lt; void, std::error_code &gt;</td></tr>
<tr class="memdesc:a6e2510763fd04e3b4b36c9026b29d9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable IO processing for the associated network IO handler with simple variable length message frame logic.  <br /></td></tr>
<tr class="separator:a6e2510763fd04e3b4b36c9026b29d9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eee63c9d7d980675bd929b4a1f045c5" id="r_a6eee63c9d7d980675bd929b4a1f045c5"><td class="memTemplParams" colspan="2">template&lt;typename MH &gt; </td></tr>
<tr class="memitem:a6eee63c9d7d980675bd929b4a1f045c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6eee63c9d7d980675bd929b4a1f045c5">start_io</a> (std::string_view delimiter, MH &amp;&amp;msg_handler) -&gt; nonstd::expected&lt; void, std::error_code &gt;</td></tr>
<tr class="memdesc:a6eee63c9d7d980675bd929b4a1f045c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable IO processing for the associated network IO handler with delimeter logic.  <br /></td></tr>
<tr class="separator:a6eee63c9d7d980675bd929b4a1f045c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314b0fd2e8a0e890564041829851ab98" id="r_a314b0fd2e8a0e890564041829851ab98"><td class="memTemplParams" colspan="2">template&lt;typename MH &gt; </td></tr>
<tr class="memitem:a314b0fd2e8a0e890564041829851ab98"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a314b0fd2e8a0e890564041829851ab98">start_io</a> (std::size_t read_size, MH &amp;&amp;msg_handler) -&gt; nonstd::expected&lt; void, std::error_code &gt;</td></tr>
<tr class="memdesc:a314b0fd2e8a0e890564041829851ab98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable IO processing for the associated network IO handler with fixed or maximum buffer size logic.  <br /></td></tr>
<tr class="separator:a314b0fd2e8a0e890564041829851ab98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5907f7d25e379133bf10e2e0334161" id="r_a1d5907f7d25e379133bf10e2e0334161"><td class="memTemplParams" colspan="2">template&lt;typename MH &gt; </td></tr>
<tr class="memitem:a1d5907f7d25e379133bf10e2e0334161"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1d5907f7d25e379133bf10e2e0334161">start_io</a> (const endpoint_type &amp;endp, std::size_t max_size, MH &amp;&amp;msg_handler) -&gt; nonstd::expected&lt; void, std::error_code &gt;</td></tr>
<tr class="memdesc:a1d5907f7d25e379133bf10e2e0334161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable IO processing for the associated network IO handler with a maximum buffer size and a default destination endpoint.  <br /></td></tr>
<tr class="separator:a1d5907f7d25e379133bf10e2e0334161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7342e001e196d147c65c7713e22021b" id="r_ac7342e001e196d147c65c7713e22021b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7342e001e196d147c65c7713e22021b">start_io</a> () -&gt; nonstd::expected&lt; void, std::error_code &gt;</td></tr>
<tr class="memdesc:ac7342e001e196d147c65c7713e22021b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable IO processing for the associated network IO handler with no incoming message handling.  <br /></td></tr>
<tr class="separator:ac7342e001e196d147c65c7713e22021b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7868d11e3c02f27bfaa6316b397e84d" id="r_ae7868d11e3c02f27bfaa6316b397e84d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7868d11e3c02f27bfaa6316b397e84d">start_io</a> (const endpoint_type &amp;endp) -&gt; nonstd::expected&lt; void, std::error_code &gt;</td></tr>
<tr class="memdesc:ae7868d11e3c02f27bfaa6316b397e84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable IO processing for the associated network IO handler with no incoming message handling, but with a default destination endpoint.  <br /></td></tr>
<tr class="separator:ae7868d11e3c02f27bfaa6316b397e84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad985742711dd1c4812649b8e1076ba" id="r_a8ad985742711dd1c4812649b8e1076ba"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ad985742711dd1c4812649b8e1076ba">stop_io</a> () -&gt; nonstd::expected&lt; void, std::error_code &gt;</td></tr>
<tr class="memdesc:a8ad985742711dd1c4812649b8e1076ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop IO processing and close the associated network IO handler.  <br /></td></tr>
<tr class="separator:a8ad985742711dd1c4812649b8e1076ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c1f76f007ce79681a97db38e7f744f" id="r_ab9c1f76f007ce79681a97db38e7f744f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9c1f76f007ce79681a97db38e7f744f">operator==</a> (const <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">basic_io_interface</a>&lt; IOT &gt; &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:ab9c1f76f007ce79681a97db38e7f744f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> objects for equality.  <br /></td></tr>
<tr class="separator:ab9c1f76f007ce79681a97db38e7f744f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb05ef449d0186d1277d3208ccf2450" id="r_aecb05ef449d0186d1277d3208ccf2450"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecb05ef449d0186d1277d3208ccf2450">operator&lt;</a> (const <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">basic_io_interface</a>&lt; IOT &gt; &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:aecb05ef449d0186d1277d3208ccf2450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> objects for ordering purposes.  <br /></td></tr>
<tr class="separator:aecb05ef449d0186d1277d3208ccf2450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec49ffeef68e531a716724a09a59a69" id="r_a5ec49ffeef68e531a716724a09a59a69"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ec49ffeef68e531a716724a09a59a69">get_ptr</a> () const noexcept</td></tr>
<tr class="memdesc:a5ec49ffeef68e531a716724a09a59a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a raw pointer to an associated IO handler.  <br /></td></tr>
<tr class="separator:a5ec49ffeef68e531a716724a09a59a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a927bf91fdc033397db0876d27e3c2d06" id="r_a927bf91fdc033397db0876d27e3c2d06"><td class="memItemLeft" align="right" valign="top"><a id="a927bf91fdc033397db0876d27e3c2d06" name="a927bf91fdc033397db0876d27e3c2d06"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>tcp_io_interface</b> = <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">basic_io_interface</a>&lt;tcp_io&gt;</td></tr>
<tr class="memdesc:a927bf91fdc033397db0876d27e3c2d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using declaration for a TCP based <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> type. <br /></td></tr>
<tr class="separator:a927bf91fdc033397db0876d27e3c2d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ea52c44a3125addbb9473572b1312d" id="r_a48ea52c44a3125addbb9473572b1312d"><td class="memItemLeft" align="right" valign="top"><a id="a48ea52c44a3125addbb9473572b1312d" name="a48ea52c44a3125addbb9473572b1312d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>udp_io_interface</b> = <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">basic_io_interface</a>&lt;udp_io&gt;</td></tr>
<tr class="memdesc:a48ea52c44a3125addbb9473572b1312d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using declaration for a UDP based <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> type. <br /></td></tr>
<tr class="separator:a48ea52c44a3125addbb9473572b1312d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070c8dd169c04a878348f2389ea60a35" id="r_a070c8dd169c04a878348f2389ea60a35"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a070c8dd169c04a878348f2389ea60a35">hdr_decoder_func</a> = std::size_t (*)(const std::byte* ptr, std::size_t sz)</td></tr>
<tr class="memdesc:a070c8dd169c04a878348f2389ea60a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for a variable length message header decoder function, used in one of the <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> <code>start_io</code> methods.  <br /></td></tr>
<tr class="separator:a070c8dd169c04a878348f2389ea60a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename IOT&gt;<br />
class chops::net::basic_io_interface&lt; IOT &gt;</div><p>The <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> class template provides access to an underlying network IO handler (TCP or UDP IO handler), primarily for calling the <code>start_io</code>, <code>stop_io</code>, and <code>make_io_output</code> methods. </p>
<p>The <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> class provides the primary application interface to start network IO processing, whether TCP or UDP. This class provides methods to start IO processing (i.e. start read processing and enable write processing), stop IO processing (if needed, typically doesn't need to be directly called), and access the IO handler socket (e.g. to retrieve or modify socket options). It also provides a method to create a <code><a class="el" href="classchops_1_1net_1_1basic__io__output.html" title="The basic_io_output class template provides methods for sending data to an associated network IO hand...">basic_io_output</a></code> object for sending data.</p>
<p>The <code>start_io</code> and <code>stop_io</code> methods are not a data flow toggle. In other words, once <code>start_io</code> is called, no other <code>start_io</code> methods can be called. If <code>stop_io</code> is called, connection teardown (or socket close) is initiated, and <code>start_io</code> will not be possible.</p>
<p>Calling <code>stop_io</code> is not necessary and is only needed if an application needs to close a connection or socket directly and not through other means (e.g. a <code><a class="el" href="classchops_1_1net_1_1net__entity.html" title="The net_entity class provides the primary application interface into the TCP acceptor,...">net_entity</a></code> <code>close</code> or a connection termination or a message handler <code>false</code> return).</p>
<p>This class is a lightweight value class, allowing <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> objects to be copied and used in multiple places in an application, all of them accessing the same network IO handler. Internally, a <code>std::weak</code> pointer is used to link the <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> object with a network IO handler.</p>
<p>A <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> object is provided for application use through a state change function object callback. This occurs when a <code><a class="el" href="classchops_1_1net_1_1net__entity.html" title="The net_entity class provides the primary application interface into the TCP acceptor,...">net_entity</a></code> creates the underlying network IO handler, or the network IO handler is being closed and destructed. The <code><a class="el" href="classchops_1_1net_1_1net__entity.html" title="The net_entity class provides the primary application interface into the TCP acceptor,...">net_entity</a></code> class documentation provides more detail.</p>
<p>A <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> object is either associated with a network IO handler (i.e. the <code>std::weak</code> pointer is good), or not. The <code>is_valid</code> method queries if the association is present. Note that even if the <code>std::weak_pointer</code> is valid, the network IO handler might be in the process of closing or being destructed.</p>
<p>Applications can default construct a <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> object, but it is not useful until a valid <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> object is assigned to it (typically this would be performed through the state change function object callback).</p>
<p>A <code><a class="el" href="classchops_1_1net_1_1basic__io__output.html" title="The basic_io_output class template provides methods for sending data to an associated network IO hand...">basic_io_output</a></code> object can be created from a <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code>, allowing the sending of data to the underlying network IO handler.</p>
<p>The underlying network IO handler socket can be accessed through the <code>visit_socket</code> method. This allows socket options to be queried and set (or other useful socket methods to be called).</p>
<p>Appropriate comparison operators are provided to allow <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> objects to be used in associative or sequence containers.</p>
<p>All <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> methods can be called concurrently from multiple threads, but calling <code>stop_io</code> at the same time as <code>start_io</code> from multiple threads may result in undesired application behavior.</p>
<p>Error handling is provided by returning a <code>nonstd::expected</code> object on most methods. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7a8a1629cbe35c659fd5455ba3132649" name="a7a8a1629cbe35c659fd5455ba3132649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8a1629cbe35c659fd5455ba3132649">&#9670;&#160;</a></span>basic_io_interface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IOT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1net_1_1basic__io__interface.html">chops::net::basic_io_interface</a>&lt; IOT &gt;::basic_io_interface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default construct a <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code>. </p>
<p>A <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> is not useful until an active <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> is assigned into it. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5ec49ffeef68e531a716724a09a59a69" name="a5ec49ffeef68e531a716724a09a59a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec49ffeef68e531a716724a09a59a69">&#9670;&#160;</a></span>get_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IOT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void * <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">chops::net::basic_io_interface</a>&lt; IOT &gt;::get_ptr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a raw pointer to an associated IO handler. </p>
<p>This method provides a raw pointer to an associated IO handler (or <code>nullptr</code>). This value can be used for logging or associative container lookup purposes. In particular, this value can be used to correlate multiple error messages from the same IO handler instantiation.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer value, which may be a <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="ad9a69a98211370437e7e745d7e0ed921" name="ad9a69a98211370437e7e745d7e0ed921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a69a98211370437e7e745d7e0ed921">&#9670;&#160;</a></span>is_io_started()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IOT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">chops::net::basic_io_interface</a>&lt; IOT &gt;::is_io_started </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; nonstd::expected&lt;bool, std::error_code&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether an IO handler is in a started state or not. </p>
<dl class="section return"><dt>Returns</dt><dd><code>nonstd::expected</code> - <code>bool</code> on success, specifying whether <code>start_io</code> on the IO handler has been called (if <code>false</code>, the IO handler has not been started or is in a stopped state); on error (if no associated IO handler), a <code>std::error_code</code> is returned. </dd></dl>

</div>
</div>
<a id="aadf5455c5e73634c98f324069c553c7d" name="aadf5455c5e73634c98f324069c553c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf5455c5e73634c98f324069c553c7d">&#9670;&#160;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IOT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">chops::net::basic_io_interface</a>&lt; IOT &gt;::is_valid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether an IO handler is associated with this object. </p>
<p>If <code>true</code>, an IO handler (e.g. TCP or UDP IO handler) is associated. However, the IO handler may be closing down and may not allow further operations.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if associated with an IO handler. </dd></dl>

</div>
</div>
<a id="af62257614a16c0076afe0244ec6e3ade" name="af62257614a16c0076afe0244ec6e3ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62257614a16c0076afe0244ec6e3ade">&#9670;&#160;</a></span>make_io_output()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IOT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">chops::net::basic_io_interface</a>&lt; IOT &gt;::make_io_output </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; nonstd::expected&lt;<a class="el" href="classchops_1_1net_1_1basic__io__output.html">basic_io_output</a>&lt;IOT&gt;, std::error_code&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <code><a class="el" href="classchops_1_1net_1_1basic__io__output.html" title="The basic_io_output class template provides methods for sending data to an associated network IO hand...">basic_io_output</a></code> object from the associated IO handler. </p>
<p>A <code><a class="el" href="classchops_1_1net_1_1basic__io__output.html" title="The basic_io_output class template provides methods for sending data to an associated network IO hand...">basic_io_output</a></code> object is used for sending data. A <code><a class="el" href="classchops_1_1net_1_1basic__io__output.html" title="The basic_io_output class template provides methods for sending data to an associated network IO hand...">basic_io_output</a></code> object will be created even if <code>start_io</code> has not been called, and attempting to send data before <code>start_io</code> is called will result in discarded data.</p>
<dl class="section return"><dt>Returns</dt><dd><code>nonstd::expected</code> - <code><a class="el" href="classchops_1_1net_1_1basic__io__output.html" title="The basic_io_output class template provides methods for sending data to an associated network IO hand...">basic_io_output</a></code> on success, either a <code>tcp_io_output</code> or <code>udp_io_output</code>; on error (if no associated IO handler), a <code>std::error_code</code> is returned. </dd></dl>

</div>
</div>
<a id="aecb05ef449d0186d1277d3208ccf2450" name="aecb05ef449d0186d1277d3208ccf2450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb05ef449d0186d1277d3208ccf2450">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IOT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">chops::net::basic_io_interface</a>&lt; IOT &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">basic_io_interface</a>&lt; IOT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> objects for ordering purposes. </p>
<p>The comparison is made through the <code>std::shared_ptr</code> <code>operator&lt;</code> method. All invalid <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> objects are less than valid ones. When both are valid, the address ordering is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>As described in the comments. </dd></dl>

</div>
</div>
<a id="ab9c1f76f007ce79681a97db38e7f744f" name="ab9c1f76f007ce79681a97db38e7f744f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c1f76f007ce79681a97db38e7f744f">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IOT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">chops::net::basic_io_interface</a>&lt; IOT &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">basic_io_interface</a>&lt; IOT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> objects for equality. </p>
<p>The comparison is made through the <code>std::shared_ptr</code> <code>operator==</code> method. The comparison is made on addresses if both <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> objects are valid. If both <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> objects are invalid, <code>true</code> is returned (this implies that all invalid <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> objects are equivalent). If one is valid and the other invalid, <code>false</code> is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>As described in the comments. </dd></dl>

</div>
</div>
<a id="ac7342e001e196d147c65c7713e22021b" name="ac7342e001e196d147c65c7713e22021b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7342e001e196d147c65c7713e22021b">&#9670;&#160;</a></span>start_io() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IOT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">chops::net::basic_io_interface</a>&lt; IOT &gt;::start_io </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; nonstd::expected&lt;void, std::error_code&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable IO processing for the associated network IO handler with no incoming message handling. </p>
<p>This method is implemented for both TCP and UDP IO handlers.</p>
<p>This method is used to enable IO processing where only sends are needed (and no incoming message handling).</p>
<p>For TCP IO handlers, a read will be started, but no data processed (typically if the read completes it is due to an error condition). For UDP IO handlers, no reads are started.</p>
<dl class="section return"><dt>Returns</dt><dd><code>nonstd::expected</code> - IO is started on success; on error, a <code>std::error_code</code> is returned. </dd></dl>

</div>
</div>
<a id="ae7868d11e3c02f27bfaa6316b397e84d" name="ae7868d11e3c02f27bfaa6316b397e84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7868d11e3c02f27bfaa6316b397e84d">&#9670;&#160;</a></span>start_io() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IOT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">chops::net::basic_io_interface</a>&lt; IOT &gt;::start_io </td>
          <td>(</td>
          <td class="paramtype">const endpoint_type &amp;</td>          <td class="paramname"><span class="paramname"><em>endp</em></span></td><td>)</td>
          <td> -&gt; nonstd::expected&lt;void, std::error_code&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable IO processing for the associated network IO handler with no incoming message handling, but with a default destination endpoint. </p>
<p>This method is not implemented for TCP IO handlers (only for UDP IO handlers).</p>
<p>This allows the <code>send</code> method without an endpoint to be called for UDP datagrams.</p>
<p>This method is used to enable IO processing where only sends are needed (and no incoming message handling).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endp</td><td>Default destination <code>asio::ip::udp::endpoint</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>nonstd::expected</code> - IO is started on success; on error, a <code>std::error_code</code> is returned. </dd></dl>

</div>
</div>
<a id="a1d5907f7d25e379133bf10e2e0334161" name="a1d5907f7d25e379133bf10e2e0334161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5907f7d25e379133bf10e2e0334161">&#9670;&#160;</a></span>start_io() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IOT &gt; </div>
<div class="memtemplate">
template&lt;typename MH &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">chops::net::basic_io_interface</a>&lt; IOT &gt;::start_io </td>
          <td>(</td>
          <td class="paramtype">const endpoint_type &amp;</td>          <td class="paramname"><span class="paramname"><em>endp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MH &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>msg_handler</em></span>&#160;) -&gt; nonstd::expected&lt;void, std::error_code&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable IO processing for the associated network IO handler with a maximum buffer size and a default destination endpoint. </p>
<p>This method is not implemented for TCP IO handlers (only for UDP IO handlers).</p>
<p>This allows the <code>send</code> method without an endpoint to be called for UDP datagrams. The buffer will be sent to this destination endpoint.</p>
<p>The maximum size parameter is the same as the corresponding (without default destination endpoint) <code>start_io</code> method.</p>
<p>Sends (writes) are enabled after this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endp</td><td>Default destination <code>asio::ip::udp::endpoint</code>.</td></tr>
    <tr><td class="paramname">max_size</td><td>Maximum UDP datagram size.</td></tr>
    <tr><td class="paramname">msg_handler</td><td>A message handler function object callback. The signature of the callback is:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">bool (asio::const_buffer,</div>
<div class="line">      chops::net::udp_io_output, <span class="comment">// basic_io_output&lt;udp_io&gt;</span></div>
<div class="line">      asio::ip::udp::endpoint);</div>
</div><!-- fragment --><p>Returning <code>false</code> from the message handler callback causes the UDP socket to be closed.</p>
<p>The message handler function object is moved if possible, otherwise it is copied. State data should be movable or copyable.</p>
<dl class="section return"><dt>Returns</dt><dd><code>nonstd::expected</code> - IO is started on success; on error, a <code>std::error_code</code> is returned. </dd></dl>

</div>
</div>
<a id="a6e2510763fd04e3b4b36c9026b29d9c2" name="a6e2510763fd04e3b4b36c9026b29d9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2510763fd04e3b4b36c9026b29d9c2">&#9670;&#160;</a></span>start_io() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IOT &gt; </div>
<div class="memtemplate">
template&lt;typename MH &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">chops::net::basic_io_interface</a>&lt; IOT &gt;::start_io </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>header_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MH &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>msg_handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a070c8dd169c04a878348f2389ea60a35">hdr_decoder_func</a></td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;) -&gt; nonstd::expected&lt;void, std::error_code&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable IO processing for the associated network IO handler with simple variable length message frame logic. </p>
<p>This method is not implemented for UDP IO handlers.</p>
<p>For TCP IO handlers, this starts read processing using a message handler function object callback and a simple variable length message header decoder function pointer. The message frame TCP processing is similar to the generalized message frame processing except that only simple variable length messages are supported. "Simple" means a fixed size header followed by one variable length body. The header must be able to be decoded with a simple function that returns the size (in bytes) of the body when given the full, fixed size header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header_size</td><td>The initial read size (in bytes) of each incoming message, which should match the header size of the header decoder function.</td></tr>
    <tr><td class="paramname">msg_handler</td><td>A message handler function object callback. The signature of the callback is:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">bool (asio::const_buffer,</div>
<div class="line">      chops::net::tcp_io_output, <span class="comment">// basic_io_output&lt;tcp_io&gt;</span></div>
<div class="line">      asio::ip::tcp::endpoint);</div>
</div><!-- fragment --><p>The buffer (first parameter) always references a full message. The <code><a class="el" href="classchops_1_1net_1_1basic__io__output.html" title="The basic_io_output class template provides methods for sending data to an associated network IO hand...">basic_io_output</a></code> can be used for sending a reply. The endpoint is the remote endpoint that sent the data (not used in the <code>send</code> method call, but may be useful for other purposes).</p>
<p>Returning <code>false</code> from the message handler callback causes the connection to be closed.</p>
<p>The message handler function object is moved if possible, otherwise it is copied. State data should be movable or copyable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A function that is of type <code>hdr_decoder_func</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>nonstd::expected</code> - IO is started on success; on error, a <code>std::error_code</code> is returned. </dd></dl>

</div>
</div>
<a id="a26e69fa899322103030acca219d65cf2" name="a26e69fa899322103030acca219d65cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e69fa899322103030acca219d65cf2">&#9670;&#160;</a></span>start_io() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IOT &gt; </div>
<div class="memtemplate">
template&lt;typename MH , typename MF &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">chops::net::basic_io_interface</a>&lt; IOT &gt;::start_io </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>header_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MH &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>msg_handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MF &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>msg_frame</em></span>&#160;) -&gt; nonstd::expected&lt;void, std::error_code&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable IO processing for the associated network IO handler with message frame logic. </p>
<p>This method is not implemented for UDP IO handlers.</p>
<p>For TCP IO handlers, this starts read processing using a message handler function object callback and a message frame function object callback. Sends (writes) are enabled after this call.</p>
<p>This method is used for message frame based TCP processing. The logic is "read header, process data to determine size of rest of message, read rest
of message". The message frame function object callback implements this logic. Once a complete message has been read, the message handler function object callback is invoked. There may be multiple iterations of calling the message frame function object before the message frame determines the complete message has been read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header_size</td><td>The initial read size (in bytes) of each incoming message.</td></tr>
    <tr><td class="paramname">msg_handler</td><td>A message handler function object callback. The signature of the callback is:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">bool (asio::const_buffer,</div>
<div class="line">      chops::net::tcp_io_output, <span class="comment">// basic_io_output&lt;tcp_io&gt;</span></div>
<div class="line">      asio::ip::tcp::endpoint);</div>
</div><!-- fragment --><p>The buffer (first parameter) always references a full message. The <code><a class="el" href="classchops_1_1net_1_1basic__io__output.html" title="The basic_io_output class template provides methods for sending data to an associated network IO hand...">basic_io_output</a></code> can be used for sending a reply. The endpoint is the remote endpoint that sent the data (not used in the <code>send</code> method call, but may be useful for other purposes).</p>
<p>Returning <code>false</code> from the message handler callback causes the connection to be closed.</p>
<p>The message handler function object is moved if possible, otherwise it is copied. State data should be movable or copyable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg_frame</td><td>A message frame function object callback. The signature of the callback is:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">std::size_t (asio::mutable_buffer);</div>
</div><!-- fragment --><p>Each time the message frame callback is called by the Chops Net IP IO handler, the next chunk of incoming bytes is passed through the buffer parameter.</p>
<p>The callback returns the size of the next read, or zero as a notification that the complete message has been called and the message handler is to be invoked.</p>
<p>If there is non-trivial processing that is performed in the message frame object and the application wishes to keep any resulting state (typically to use within the message handler), one option is to design a single class that provides two operator function call overloads and use the same object (via <code>std::ref</code>) for both the message handler and the message frame processing.</p>
<p>The message frame function object is moved if possible, otherwise it is copied. State data should be movable or copyable.</p>
<dl class="section return"><dt>Returns</dt><dd><code>nonstd::expected</code> - IO is started on success; on error, a <code>std::error_code</code> is returned. </dd></dl>

</div>
</div>
<a id="a314b0fd2e8a0e890564041829851ab98" name="a314b0fd2e8a0e890564041829851ab98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314b0fd2e8a0e890564041829851ab98">&#9670;&#160;</a></span>start_io() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IOT &gt; </div>
<div class="memtemplate">
template&lt;typename MH &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">chops::net::basic_io_interface</a>&lt; IOT &gt;::start_io </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>read_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MH &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>msg_handler</em></span>&#160;) -&gt; nonstd::expected&lt;void, std::error_code&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable IO processing for the associated network IO handler with fixed or maximum buffer size logic. </p>
<p>This method is implemented for both TCP and UDP IO handlers.</p>
<p>For TCP IO handlers, this reads a fixed size message which is then passed to the message handler function object.</p>
<p>For UDP IO handlers, this specifies the maximum size of the datagram. For IPv4 this value can be up to 65,507 (for IPv6 the maximum is larger). If the incoming datagram is larger than the specified size, data will be truncated or lost.</p>
<p>Sends (writes) are enabled after this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_size</td><td>Maximum UDP datagram size or TCP fixed read size.</td></tr>
    <tr><td class="paramname">msg_handler</td><td>A message handler function object callback. The signature of the callback is:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// TCP io:</span></div>
<div class="line">bool (asio::const_buffer,</div>
<div class="line">      chops::net::tcp_io_output, <span class="comment">// basic_io_output&lt;tcp_io&gt;</span></div>
<div class="line">      asio::ip::tcp::endpoint);</div>
<div class="line"><span class="comment">// UDP io:</span></div>
<div class="line">bool (asio::const_buffer,</div>
<div class="line">      chops::net::udp_io_output, <span class="comment">// basic_io_output&lt;udp_io&gt;</span></div>
<div class="line">      asio::ip::udp::endpoint);</div>
</div><!-- fragment --><p>Returning <code>false</code> from the message handler callback causes the TCP connection or UDP socket to be closed.</p>
<p>The message handler function object is moved if possible, otherwise it is copied. State data should be movable or copyable.</p>
<dl class="section return"><dt>Returns</dt><dd><code>nonstd::expected</code> - IO is started on success; on error, a <code>std::error_code</code> is returned. </dd></dl>

</div>
</div>
<a id="a6eee63c9d7d980675bd929b4a1f045c5" name="a6eee63c9d7d980675bd929b4a1f045c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eee63c9d7d980675bd929b4a1f045c5">&#9670;&#160;</a></span>start_io() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IOT &gt; </div>
<div class="memtemplate">
template&lt;typename MH &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">chops::net::basic_io_interface</a>&lt; IOT &gt;::start_io </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MH &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>msg_handler</em></span>&#160;) -&gt; nonstd::expected&lt;void, std::error_code&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable IO processing for the associated network IO handler with delimeter logic. </p>
<p>This method is not implemented for UDP IO handlers.</p>
<p>For TCP IO handlers, this starts read processing using a message handler function object callback. Sends (writes) are enabled after this call.</p>
<p>This method is used for delimiter based TCP processing (typically text based messages in TCP streams). The logic is "read data until the delimiter characters 
match" (which are usually "end-of-line" sequences). The message handler function object callback is then invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>Delimiter characters denoting end of each message.</td></tr>
    <tr><td class="paramname">msg_handler</td><td>A message handler function object callback. The signature of the callback is:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">bool (asio::const_buffer,</div>
<div class="line">      chops::net::tcp_io_output, <span class="comment">// basic_io_output&lt;tcp_io&gt;</span></div>
<div class="line">      asio::ip::tcp::endpoint);</div>
</div><!-- fragment --><p>The buffer points to the complete message including the delimiter sequence. The <code><a class="el" href="classchops_1_1net_1_1basic__io__output.html" title="The basic_io_output class template provides methods for sending data to an associated network IO hand...">basic_io_output</a></code> can be used for sending a reply, and the endpoint is the remote endpoint that sent the data. Returning <code>false</code> from the message handler callback causes the connection to be closed.</p>
<p>The message handler function object is moved if possible, otherwise it is copied. State data should be movable or copyable.</p>
<dl class="section return"><dt>Returns</dt><dd><code>nonstd::expected</code> - IO is started on success; on error, a <code>std::error_code</code> is returned. </dd></dl>

</div>
</div>
<a id="a8ad985742711dd1c4812649b8e1076ba" name="a8ad985742711dd1c4812649b8e1076ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad985742711dd1c4812649b8e1076ba">&#9670;&#160;</a></span>stop_io()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IOT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">chops::net::basic_io_interface</a>&lt; IOT &gt;::stop_io </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; nonstd::expected&lt;void, std::error_code&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop IO processing and close the associated network IO handler. </p>
<p>After this call, connection disconnect or socket close processing will occur, a state change function object callback will be invoked, and eventually the IO handler object will be destructed. <code>start_io</code> cannot be called after <code>stop_io</code> (in other words, <code>start_io</code> followed by <code>stop_io</code> followed by <code>start_io</code>, etc is not supported).</p>
<p>For TCP entities (connectors and acceptors), the TCP connection will be taken down, but the entity will remain active. For UDP entities <code>stop_io</code> is equivalent to calling <code>stop</code> on the <code><a class="el" href="classchops_1_1net_1_1net__entity.html" title="The net_entity class provides the primary application interface into the TCP acceptor,...">net_entity</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>nonstd::expected</code> - IO is started on success; on error, a <code>std::error_code</code> is returned. </dd></dl>

</div>
</div>
<a id="a1af5d06c46ef636b1ad12ed98b1daae0" name="a1af5d06c46ef636b1ad12ed98b1daae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af5d06c46ef636b1ad12ed98b1daae0">&#9670;&#160;</a></span>visit_socket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IOT &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1net_1_1basic__io__interface.html">chops::net::basic_io_interface</a>&lt; IOT &gt;::visit_socket </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td> -&gt; nonstd::expected&lt;void, std::error_code&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide an application supplied function object which will be called with a reference to the associated IO handler socket. </p>
<p>The function object must have one of the following signatures, depending on the IO handler type:</p>
<div class="fragment"><div class="line">void (asio::ip::tcp::socket&amp;); <span class="comment">// TCP IO</span></div>
<div class="line">void (asio::ip::udp::socket&amp;); <span class="comment">// UDP IO</span></div>
</div><!-- fragment --><p>Within the function object socket options can be queried or modified.</p>
<dl class="section return"><dt>Returns</dt><dd><code>nonstd::expected</code> - socket has been visited on success; on error (if no associated IO handler), a <code>std::error_code</code> is returned. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a070c8dd169c04a878348f2389ea60a35" name="a070c8dd169c04a878348f2389ea60a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070c8dd169c04a878348f2389ea60a35">&#9670;&#160;</a></span>hdr_decoder_func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IOT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a070c8dd169c04a878348f2389ea60a35">hdr_decoder_func</a> = std::size_t (*)(const std::byte* ptr, std::size_t sz)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signature for a variable length message header decoder function, used in one of the <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> <code>start_io</code> methods. </p>
<p>Given a buffer of <code>std::bytes</code> corresponding to a header on a variable length message, decode the header and return the length in bytes of the message body. Specifically, only the size of the body should be returned, not the full message size (header plus body).</p>
<p>For example, a 14 byte header that contains a full message length would need to subtract 14 from the length before returning the value from this function.</p>
<p>This can only be a function pointer, not a function object. If state needs to be stored or more complex logic needed than can be provided by a simple function, then the <code>start_io</code> that takes a full message frame function object should be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the beginning of the variable len message header.</td></tr>
    <tr><td class="paramname">sz</td><td>The size of the header buffer, in bytes, which should be the same for every call and match the parameter given to the <code><a class="el" href="classchops_1_1net_1_1basic__io__interface.html" title="The basic_io_interface class template provides access to an underlying network IO handler (TCP or UDP...">basic_io_interface</a></code> <code>start_io</code> call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/github/workspace/include/net_ip/<a class="el" href="basic__io__interface_8hpp_source.html">basic_io_interface.hpp</a></li>
<li>/github/workspace/include/net_ip/<a class="el" href="io__type__decls_8hpp_source.html">io_type_decls.hpp</a></li>
<li>/github/workspace/include/net_ip/<a class="el" href="simple__variable__len__msg__frame_8hpp_source.html">simple_variable_len_msg_frame.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
